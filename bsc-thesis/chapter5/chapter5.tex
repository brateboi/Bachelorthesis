\documentclass[../thesis.tex]{subfiles}
\begin{document}

% These macros are only used for the pseudo-code example.
\newcommand{\str}[1]{\textsc{#1}}
\newcommand{\var}[1]{\textit{#1}}
\newcommand{\op}[1]{\textsl{#1}}
\def \ifempty#1{\def\temp{#1} \ifx\temp\empty }
\newcommand{\msg}[2]{\ensuremath{\ifempty{#2} [\str{#1}] \else [\str{#1}, {#2}] \fi}}
\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\nil}{\ensuremath{\bot}}
\newcommand{\false}{\textsc{false}\xspace}
\newcommand{\true}{\textsc{true}\xspace}

\newcommand\lastts{\var{lastts}\xspace}
\newcommand\nextts{\var{nextts}\xspace}
\newcommand\trusted{\var{trusted}\xspace}
\newcommand\newepoch{\var{newepoch}\xspace}
\newcommand\leader{\var{leader}\xspace}
\newcommand\ts{\var{ts}\xspace}
\newcommand{\CK}{\ensuremath{\mathcal{K}}\xspace}
\newcommand{\CP}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\CQ}{\ensuremath{\mathcal{Q}}\xspace}

\chapter{Algorithm for $R$ between two arbitrary points in a mesh}
To measure the Dirichlet energy, we need to calculate the rotation coefficient
between to arbitrary points $q$ and $p$ that do not necessarily lie within the same 
tetrahedron. Since the metric and curl is different in each tet, we need to be
able to efficiently determine all tets that get intersected by the straight
line from $q$ to $p$, and use the correct metric for each corresponding
line segment.
The calculation for the coefficient then works in the following way:
\begin{algo*}
  \vbox{
    \small
    \begin{numbertabbing}
      xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
      \textbf{Input} $(q,p)$ \label{}\\
      \> $\str{lineSegments} \gets$ $\op{tetFinder($q,p$)}$ //returns all tets intersected by the line $\Vec{pq}$ with the line segments within them \label{}\\
      \> $R \gets \Id$ \label{}\\
      \> \textbf{for each} $\str{segment}$ \textbf{in} $\str{lineSegments}$ \label{}\\
      \> \> $R \gets R \cdot \op{calcCoeff}(\str{segment})$ \label{}\\
      \\
      \textbf{return} $R$ \label{}
    \end{numbertabbing}
  }
  \caption{Rotation coefficient $R$ between $q$ and $p$}
\end{algo*}

The missing component here is how do we efficiently find all tetrahedra
that get intersected. One possibility would be to use ray-triangle intersection and
test against the whole mesh, but this is not practical, as we have have local information
that we can exploit.
\begin{figure}[htb]
  \centering
  \def\svgwidth{10em}
  \input{figures/illustration.pdf_tex}
  \caption*{Mesh}        
\end{figure}


\begin{algo*}
  \vbox{
    \small
    \begin{numbertabbing}
      xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
      \textbf{State} \label{}\\
      \> \(\lastts \gets 0\): most recently started epoch \label{}\\
      \> \(\nextts \gets 0\): timestamp of the next epoch \label{}\\
      \> \(\newepoch \gets \msg{\nil}{}^n\): list of \str{newepoch} messages\label{}\\
      \\
      \textbf{upon event} \(\op{complain}(p_{\ell})\) \textbf{such that} \( p_{\ell} = \leader(\lastts)\)  \textbf{do} \label{}\\  
      \> \textbf{if} \(\nextts = \lastts\) \textbf{then}\label{}\\
      \> \> \(\nextts \gets \lastts + 1\) \label{}\\
      \> \> send message \(\msg{\str{newepoch}}{\nextts}\) to all \(p_j \in \mathcal{P}\) \label{}\\
      \\
      \textbf{upon} receiving a message
      \(\msg{\str{newepoch}}{\ts}\)  from $p_j$
      \textbf{such that}  \(\ts = \lastts + 1 \) \textbf{do} \label{}\\
      \> \(\newepoch[j] \gets \str{newepoch}\) \label{}\\
      \\
      \textbf{upon exists} \(\ts\) \textbf{such that} \(\{ p_j \in \CP |~\newepoch[j] = \ts \} \in \CK_i\) \textbf{and} \(\nextts = \lastts\) \textbf{do} \label{}\\
      \> \(\nextts \gets \lastts + 1\) \label{}\\
      \> send message \(\msg{\str{newepoch}}{\nextts}\) to all \(p_j \in \CP\) \label{}\\
      \\
      \textbf{upon exists} \(\ts\) \textbf{such that} \(\{ p_j \in \CP |~\newepoch[j] = \ts \} \in \CQ_i\) \textbf{and} \(\nextts > \lastts\) \textbf{do} \label{}\\
      \> \(\lastts \gets \nextts\) \label{}\\
      \> \(\newepoch \gets [\nil]^n\)\label{}\\
      \> \textbf{output} \(\op{startepoch}(\lastts, \leader(\lastts))\) \label{}
    \end{numbertabbing}
  }
  \caption{Byzantine Leader-Based Epoch-Change (process $p_i$).}
  \label{alg:epoch-change}
\end{algo*}



\end{document}