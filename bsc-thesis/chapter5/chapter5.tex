\documentclass[../thesis.tex]{subfiles}
\begin{document}

% These macros are only used for the pseudo-code example.
\newcommand{\str}[1]{\textsc{#1}}
\newcommand{\var}[1]{\textit{#1}}
\newcommand{\op}[1]{\textsl{#1}}
\def \ifempty#1{\def\temp{#1} \ifx\temp\empty }
\newcommand{\msg}[2]{\ensuremath{\ifempty{#2} [\str{#1}] \else [\str{#1}, {#2}] \fi}}
\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\nil}{\ensuremath{\bot}}
\newcommand{\false}{\textsc{false}\xspace}
\newcommand{\true}{\textsc{true}\xspace}

\newcommand\ts{\var{ts}\xspace}
\newcommand{\CK}{\ensuremath{\mathcal{K}}\xspace}
\newcommand{\CP}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\CQ}{\ensuremath{\mathcal{Q}}\xspace}

\chapter{Algorithm for $R$ between two arbitrary points in a mesh}
\label{ch:algorithm}
To measure the Dirichlet energy, we need to calculate the rotation coefficient $R$
between two arbitrary points $q$ and $p$ that do not necessarily lie within the same 
tetrahedron. Since the metric and curl is different in each tet, we need to be
able to efficiently determine all tets that get intersected by the straight
line from $q$ to $p$, and use the correct metric for each corresponding
line segment.
The calculation for the coefficient then works in the following way:
\begin{algo*}
  \vbox{
    \small
    \begin{numbertabbing}
      \reset
      xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
      \textbf{Input} $(q,p)$ \label{}\\
      \>  //returns all tets intersected by the line $\Vec{qp}$ with the line segments within them \label{}\\
      \> $\str{lineSegments} \gets$ $\op{tetFinder($q,p$)}$ \label{}\\
      \> $R \gets \Id$ \label{}\\
      \> \textbf{for each} $\str{segment}$ \textbf{in} $\str{lineSegments}$ \label{}\\
      \> \> $R \gets R \cdot \op{calcCoeff}(\str{segment})$ \label{}\\
      \\
      \textbf{return} $R$ \label{}
    \end{numbertabbing}
  }
  \caption{Rotation coefficient $R$ between $q$ and $p$}
\end{algo*}

The missing component here is how to efficiently find all tetrahedra
that get intersected. One possibility would be to use ray-triangle intersection and
test against the whole mesh, but this is not practical, as we have have local information
that we can exploit.

We use the idea of the straight walk from \emph{Walking in a Triangulation}\cite{Devillers}, which relies only on
so called \emph{orientation tests} to determine which triangles we traverse.
This chapter covers how the $\op{tetFinder}$ algorithm works, how it is made robust
against degenerate cases
and a full description of the algorithm is given, more than what is described in the reference.
\section{Framework}
\label{sec:framework}

Let $\mathcal{T}$ be a triangulation of a domain $\Omega$ that is convex.
The straight walk traverses all triangles that get intersected by the line segment
from $q$ to $p$. The algorithm first makes an initialization step to get into a valid state, 
then the straight walk can start.
To get a feeling how the algorithm works, let us go through an example in 2D.
If the algorithm was in a valid state before, the line from $q$ to $p$
intersects with some edge $\vec{lr}$. Two triangles share this edge.
We test on which side point $p$ lies of this edge to decide whether the walk continues.
If the walk continues, we jump through the edge to hop from the old triangle to a new one.
This triangle is defined by three vertices $(l,r,s)$. We decide if
the new candidate point $s$ lies on the left side or right side of the line from $q$ to $p$.
If $s$ lies on the left, point $l$ is moved, else point $r$ is moved.
A new edge intersected with the ray $\vec{qp}$ is found and the walk repeats.
This process is illustrated in Figure \ref{fig:straight-walk-2d}
\begin{figure}[htb]
  \centering
  \def\svgwidth{35em}
  \input{figures/illustration.pdf_tex}
  \caption{Straight walk step}\label{fig:straight-walk-2d}        
\end{figure}

Notice how the ray $\vec{qp}$ always intersects the edge $\vec{lr}$ at each update step.
We can use this observation to add each edge at each update step to a list.
When the algorithm terminates, we can just iterate over this list, find
the intersection point of the ray $\vec{qp}$ with the edge and calculate the rotation
coefficient for this segment.
The straight walk in 3d works similarly. The initialization step consists of finding a starting tet $t$
where $q$ is contained. Then, we find the face of the tet $t$ that gets intersected by the ray
$\vec{qp}$. Again, at each step, we know that the ray goes out of our current tet $t$ through some
face $e$ defined by vertices $uvw$. We decide if the walk continues by checking on which side $p$ lies relative to $e$.
If the walk should continue, we hop through $e$ to a new tet $t_{new}$. With two orientation tests
we decide which of the vertices $u, v, w$ gets moved to the new candidate point $s$. This defines
a new face $e_{new}$ where our ray intersects and the walk repeats.
Degenerate cases such as when the ray $\vec{qp}$ goes exactly through a vertex or
when the ray lies within a face, the algorithm may get into
an invalid state, where the algorithm may then traverse through
cells that do not get intersected by the ray. We need to detect and escape those degenerate cases
through some additional checks. These are not described in the paper\cite{Devillers}.
In most cases, a simple reinitialization is enough when the invalid state is detected.

\subsection{A note on orientation tests}
To determine on which side some point $s$ lies relative to two other points $q$ and $p$ (that represent a line) in 2D, the geometric \emph{orientation} predicate is used.
It corresponds to evaluating the sign of a determinant. Analogously in 3D, the orientation predicate
tests whether a fourth point lies above or below a plane defined by three other points.
How ``above'' the plane is defined depends on the ordering within the determinant. In the case here,
it is above if point $a$ sees the triangle $bcd$ when turning counterclockwise (see figure \ref{fig:orient2d}).
\begin{align*}
  orientation(\alpha, \beta, \gamma) &= 
  sign\left(
  \begin{vmatrix}
    \beta_x -\alpha_x & \gamma_x - \alpha_x \\
    \beta_y -\alpha_y & \gamma_y - \alpha_y 
  \end{vmatrix}\right)
  \\
  orientation(\alpha, \beta, \gamma, \delta) &= 
  sign\left(
  \begin{vmatrix}
    \beta_x -\alpha_x & \gamma_x - \alpha_x & \delta_x - \alpha_x \\
    \beta_y -\alpha_y & \gamma_y - \alpha_y & \delta_y - \alpha_y \\
    \beta_z -\alpha_z & \gamma_z - \alpha_z & \delta_z - \alpha_z
  \end{vmatrix}\right)
\end{align*}

\begin{figure}[htb]
  \centering
  \def\svgwidth{20em}
  \input{figures/orientation2d.pdf_tex}
  \caption{Orientation predicate: Point $a$ lies above the plane $bcd$ because it sees the points in counterclockwise order, $orientation(a,b,c,d)>0$}
  \label{fig:orient2d}
\end{figure}
It is important that the sign of the determinant is evaluated exactly.
If geometric predicates are implemented with floating point arithmetic,
the answers may be inconsistent and wrong.
Because of the finite mantissa in floating point representation, many numbers cannot be represented exactly.
The machine needs to round a number $x$ to its nearest number that is exactly representable.
Many times, roundoff errors occur and the result is not exact. A famous example of this phenomenon is $0.1 + 0.2 = 0.30000000000000004$.
We call the distance between two exactly representable floating point numbers \emph{machine epsilon} $\varepsilon$.
See figure \ref{fig:floatingpoint} for how this machine epsilon can cause trouble (Example from \cite{Marek}).
\begin{figure}[htb]
  \centering
  \def\svgwidth{20em}
  \input{figures/floatingpointerror.pdf_tex}
  \caption{The orientation predicate implemented with floating point arithmetic cannot distinguish these two cases.
  The orientation test calculates $(a+\varepsilon)-a$. If $a=0$, the orientation test is strictly positive.
  If $a=1$, then the result is $0$, because during the calculation the machine had to round.
  }\label{fig:floatingpoint}
\end{figure}
Because of the imprecision of floating-point arithmetic (FP), logical decisions
based on FP should be avoided.
To fix this issue, we make use of exact predicates that are implemented with arbitrary precision \cite{RichardShewchuk1997}.
It is assumed that inputs to the orientation test subroutines are exact, and during the calculation,
precision is extended as needed such that
we can be sure that the result has the correct sign.


\section{Algorithm $\op{tetFinder}$}
As described in section \ref{sec:framework}, the straight walk needs different
components to work. These components are described in the following subsections.
The final algorithm to find all intersected tetrahedra between two points is as follows.

\subsection{Starting tet}\label{subsec:starttet}
To start, the algorithm needs to know in which tet the starting point $q$ is located.
With a simple linear nearest neighbor search of point $q$, we find a good heuristic starting point
$s$. From $s$, every tet incident to $s$ is checked if it contains $q$.
Most of the times, this
method works for locating which tet contains $q$. In case it fails,
an exhaustive search through all the tets of the mesh is done to search
which tet contains $q$. Figure \ref{fig:fail} shows a constellation where the nearest
neighbor approach fails.
\begin{figure}[htb]
  \centering
  \def\svgwidth{10em}
  \input{figures/fail.pdf_tex}
  \caption{The point $s$ is the nearest neighbor to $q$. However, searching all incident triangles to $s$, point $q$ cannot be located.
  A similar example can be constructed in 3D.
  }\label{fig:fail}
\end{figure}
Checking if a point $q$ is within some tet $\mathcal{T}= [a,b,c,d]$ can be done with the orientation predicate, i.e.
$$q \in \mathcal{T} \iff \substack{
  \op{sameSign}(\op{orientation}(a,b,c,d), \op{orientation}(a,b,c,q)) \&\& \\
  \op{sameSign}(\op{orientation}(b,c,d,a), \op{orientation}(b,c,d,q)) \&\& \\
  \op{sameSign}(\op{orientation}(c,d,a,b), \op{orientation}(c,d,a,q)) \&\& \\
  \op{sameSign}(\op{orientation}(d,a,b,c), \op{orientation}(d,a,b,q))
}$$
By checking for each plane of the tet, we check if the point $q$ is on the same side of the plane 
(characterised by the same orientation sign) as the remaining vertex.
\subsection{Valid state and initialization}
To walk in the tet mesh, the algorithm needs to be in a state where everything is as expected.
In 2D, we define this valid state as
\begin{itemize}
  \item the line $\Vec{qp}$ intersects the edge defined by vertices $\Vec{lr}$
  \item vertex $l$ lies on the left of the line defined by $\Vec{qp}$
  \item vertex $r$ lies on the right of the line defined by $\Vec{qp}$
\end{itemize}
If the algorithm starts with these configurations, then in each step
the valid configuration will be preserved and all edges intersected are
traversed. 
Analogously in 3D, we define the valid state such that
\begin{itemize}
  \item the line $\Vec{qp}$ intersects the triangle defined by vertices $\triangle uvw$
  \item vertices of the triangle $\triangle uvw$ are ordered in the way that
  $$\op{orientation}(w,v,q,p)>0, \op{orientation}(v,u,q,p)>0, \op{orientation}(u,w,q,p)>0$$
\end{itemize}
Again, by starting in this configuration, all triangles $\triangle uvw$
traversed get intersected by $\Vec{qp}$. Then, we find each
intersection point with the ray, add the intersection points to a list
with the current tet $t$ and finally use this as input for
calculating the rotation coefficient as described in chapter \ref{ch:calculation}.
To get into a valid state, an initialization needs to be performed.
In \emph{Walking in a triangulation}\cite{Devillers}, they assume that
$q$ is a vertex in the tet mesh. Thus, their approach of turning around $q$
is not applicable in our case.

We solve this problem with a brute-force approach.
First, we find which tet $t$ contains $q$ as described in \ref{subsec:starttet}.
From there, we go through the four faces of the tet and check which
one gets intersected by the ray $\Vec{qp}$.
When the face which gets intersected was found,
we check the 6 permutations of the three vertices $(u,v,w)$
until the configuration is found, where the orientations are positive.

\subsection{Robust ray-triangle intersection}
\cite{segura}\emph{An algorithm for determining intersection segment-polygon in 3D}

\subsection{Robustness}


\begin{algo*}
  \vbox{
    \small
    \begin{numbertabbing}
      \reset
      xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
      \textbf{Input} $(q,p)$ \label{}\\
      \> $t = \op{LocateTet(q)}$ \label{}\\
      \> $\op{initialization(t)}$ \label{}\\
      \\
      \> // $qp$ intersects triangle $uvw$ \label{}\\
      \> // $wvqp, vuqp, uwqp$ are positively oriented \label{}\\
      \> $\str{lineSegments} = [~]$\label{}\\
      \> $\str{prev} = q$\label{}\\
      \> $\str{curr} = \op{intersection}(qp, uvw)$\label{}\\
      \\
      \> $\str{lineSegments}.\op{add}([t, \str{prev}, \str{curr}])$ \label{}\\
      \\
      \> \textbf{while} $orientation(u,w,v,p)>0$ \{ \label{}\\
      \> \> $t$ = neighbor($t$ through $uvw$) \label{}\\
      \> \> $s$ = vertex of $t, s \neq u, s \neq v, s \neq w$ \label{}\\
      \> \> $\str{prev} = \str{curr}$ \label{}\\
      \> \> \textbf{if} $orientation(u,s,q,p) > 0$ // $qp$ does not intersect triangle $usw$\label{}\\
      \> \> \> \textbf{if} $orientation(v,s,q,p) > 0$ // $qp$ intersects triangle $vsw$ \label{}\\
      \> \> \> \> u = s \label{}\\
      \> \> \> \textbf{else} // $qp$ intersects triangle $usv$ \label{}\\
      \> \> \> \> w = s \label{}\\
      \> \> \textbf{else} // $qp$ does not intersect $usv$ \label{}\\
      \> \> \> \textbf{if} $orientation(w,s,q,p) > 0$ // $qp$ intersects triangle $usw$ \label{}\\
      \> \> \> \> v = s \label{}\\
      \> \> \> \textbf{else} // $qp$ intersects triangle $vsw$ \label{}\\
      \> \> \> \> u = s \label{}\\
      \> \> $\str{curr} = \op{intersection}(qp, uvw)$ \label{}\\
      \> \> $\str{lineSegments}.\op{add}([t, \str{prev}, \str{curr}])$ \label{}\\
      \> \} // $t$ contains $p$ \label{}\\
      \> $\str{lineSegments}.\op{add}([t, \str{prev}, p])$ \label{}\\
    \end{numbertabbing}
  }
  \caption{tetFinder}
  \label{alg:tetFinder}
\end{algo*}
The algorithm uses several subroutines which are described here:
  \begin{itemize}
    \item \texttt{neighbor(t through $uvw$)} returns the tetrahedron sharing face $uvw$ with tetrahedron $t$
    \item \texttt{vertex of $t, s \neq u, s \neq v, s \neq w$} returns the remaining vertex of a tetrahedron whose other three
    vertices are known
    \item \texttt{initialization()}
  \end{itemize}


\end{document}